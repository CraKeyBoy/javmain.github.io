{"meta":{"title":"Javmain's Blog","subtitle":null,"description":null,"author":"javmain","url":"https://blog.51itzone.cn"},"pages":[{"title":"关于我","date":"2018-08-20T02:11:16.650Z","updated":"2018-08-20T02:11:16.650Z","comments":true,"path":"about/index.html","permalink":"https://blog.51itzone.cn/about/index.html","excerpt":"","text":"写在开头我们需要记录时间带给我们的记忆。 自由，开放，创新，包容。 成长总是伴随着看清自己，而所谓一生，或许只有生与活。献给一路走来的自己。 简介一枚北漂的“攻城狮”，怀着用代码改变世界的梦想，践行着极客的精神。 常用语言Java ★★★★★Python ★★★★☆C++ ★★★☆☆ 框架/工具Spring boot ★★★★★Spring cloud\\Dubbo ★★★★☆Flume\\Kafka\\Elastic ★★★★☆Docker\\MySQl\\Redis\\MongoDB\\Neo4j ★★★★☆Hadoop\\Hive\\Storm\\HDFS ★★★☆☆ 目前专注于大数据、推荐系统、知识图谱、量化交易、ML、DL 联系方式邮箱: yinyuxinqing#126#com"},{"title":"","date":"2018-08-20T02:11:16.650Z","updated":"2018-08-20T02:11:16.650Z","comments":true,"path":"books/index.html","permalink":"https://blog.51itzone.cn/books/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-08-20T02:11:16.651Z","updated":"2018-08-20T02:11:16.651Z","comments":true,"path":"categories/index.html","permalink":"https://blog.51itzone.cn/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-08-20T02:11:16.666Z","updated":"2018-08-20T02:11:16.666Z","comments":true,"path":"tags/index.html","permalink":"https://blog.51itzone.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"python 虚拟环境管理 pipenv 使用","slug":"python-pipenv-how-use","date":"2018-05-08T02:43:22.000Z","updated":"2018-08-20T02:11:16.648Z","comments":true,"path":"2018/05/08/python-pipenv-how-use/","link":"","permalink":"https://blog.51itzone.cn/2018/05/08/python-pipenv-how-use/","excerpt":"pipenv 是 2017 年 1 月由 Kennethreitz 大神创作，目前已经有 286 个版本发布，可见在 GitHub 上是非常活跃的项目。简单来说 pipenv 的是管理 python 环境和 python 依赖包的工具。使用时 pipenv 会自动创建虚拟环境，并且新增了 Pipfile 文件来维护包依赖， 新增 Pipfile.lock 已在确定环境和依赖后锁定项目，以便最终版本发布。 pipenv 还是 Python.org 正式推荐的 python 包管理工具。引用官方说明： Pipenv — the officially recommended Python packaging tool from Python.org, free (as in freedom).","text":"pipenv 是 2017 年 1 月由 Kennethreitz 大神创作，目前已经有 286 个版本发布，可见在 GitHub 上是非常活跃的项目。简单来说 pipenv 的是管理 python 环境和 python 依赖包的工具。使用时 pipenv 会自动创建虚拟环境，并且新增了 Pipfile 文件来维护包依赖， 新增 Pipfile.lock 已在确定环境和依赖后锁定项目，以便最终版本发布。 pipenv 还是 Python.org 正式推荐的 python 包管理工具。引用官方说明： Pipenv — the officially recommended Python packaging tool from Python.org, free (as in freedom). pipevn 可以解决那些问题 使用 pipevn 就相当于同时使用了 pip 和 virtualenv ，即做到包管理又可以管理虚拟环境。 使用 pipevn 解决 requirement.txt 面临的问题 pipenv 使用 Pipfile 代替 requirement.txt 文件来记录项目依赖包。 新增了 Pipfile.lock 文件来锁定 python 软件的包名及版本，以及其依赖关系的列表。 它参考了其他语言的包管理工具（bundler, composer, npm, cargo, yarn, etc.），旨在将最好的包管理工具带入 python 世界。 准备工作Mac使用 Homebrew 安装: 1brew install pipenv Ubuntu17.101234sudo apt install software-properties-common python-software-propertiessudo add-apt-repository ppa:pypa/ppasudo apt updatesudo apt install pipenv 使用 pip 安装作者推荐在 python3 下边安装，会提高与 virtualenv 的兼容性。 1pip install pipenv 为防止和系统python库产生影响，可使用此种方案安装。 1pip install --user pipenv pip 默认安装包路径为 /usr/local/lib/python2.7/site-packages 。此模式下，pip 安装包保存路径为用户库路径,可使用命令 python3 -m site –user-site 具体查看。 12$ python3 -m site --user-site/Users/apple/Library/Python/3.6/lib/python/site-packages 如果在安装后你的 shell 中 pipenv 不可用，你需要把用户库的二进制目录 /Users/apple/Library/Python/3.6/bin 添加到你的 PATH 中。 基本使用pipenv 虚拟环境使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# 创建实例项目$ mkdir PipenvDemo$ cd PipenvDemo$ touch helloworld.py$ vim helloworld.pyprint(\"hello world\")$ python3 helloworld.pyhello world# 使用 python3 创建 pipenv 虚拟环境$ pipenv install --threeCreating a Pipfile for this project… # 自动创建 PipfilePipfile.lock not found, creating… # 自动创建 Pipfile.lockLocking [dev-packages] dependencies…Locking [packages] dependencies…Updated Pipfile.lock (ca72e7)!Installing dependencies from Pipfile.lock (ca72e7)… 🐍 ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ 0/0 — 00:00:00To activate this project's virtualenv, run the following: $ pipenv shell# 查看虚拟环境位置$ pipenv --venv/Users/apple/.local/share/virtualenvs/PipenvDemo-jMTXT_BG# 查看 python 解析器位置$ pipenv --py/Users/apple/.local/share/virtualenvs/PipenvDemo-jMTXT_BG/bin/python# 运行$ pipenv run python helloworld.pyhello world# 使用 pipenv 创建的虚拟环境运行$ pipenv shellSpawning environment shell (/bin/zsh). Use 'exit' to leave.. /Users/apple/.local/share/virtualenvs/PipenvDemo-jMTXT_BG/bin/activate# 查询当前环境 python 的位置$ which python/Users/apple/.local/share/virtualenvs/PipenvDemo-jMTXT_BG/bin/python# 查看当前环境 python 的版本$ python -VPython 3.6.5# 运行 python 程序python helloworld.py# 安装依赖包$ pipenv install requestsInstalling requests…Collecting requests...Successfully installed certifi-2018.4.16 chardet-3.0.4 idna-2.6 requests-2.18.4 urllib3-1.22Adding requests to Pipfile's [packages]…Pipfile.lock (ca72e7) out of date, updating to (b14837)…Locking [dev-packages] dependencies…Locking [packages] dependencies…Updated Pipfile.lock (b14837)!... # 查看安装包依赖 $ pipenv graphrequests==2.18.4 - certifi [required: &gt;=2017.4.17, installed: 2018.4.16] - chardet [required: &gt;=3.0.2,&lt;3.1.0, installed: 3.0.4] - idna [required: &gt;=2.5,&lt;2.7, installed: 2.6] - urllib3 [required: &lt;1.23,&gt;=1.21.1, installed: 1.22]# 依赖包只安装在开发环境$ pipenv install pytest --devInstalling pytest......Adding pytest to Pipfile's [dev-packages]...# 查看 Pipfile 文件,发现 pytest 放到了 dev-packages 下$ cat Pipfile[[source]]url = \"https://pypi.org/simple\"verify_ssl = truename = \"pypi\"[packages]requests = \"*\"[dev-packages]pytest = \"*\"[requires]python_version = \"3.6\" 通过上面的示例，已经可以掌握大部分使用方法，更多命令详细内容读者可参考：basics 高级使用命令行自动完成如果你使用 bash 或者 zsh， 你可以在 ~/.bash_profile (~/.zshrc) 中设置如下变量，使用命令时按 tab 键会自动补全命令，非常方便 1eval \"$(pipenv --completion)\" 使用 requirements.txt 来安装包依赖通过 requirements.txt 安装，重用 requirements.txt 来构建新环境 1pipenv install -r requirements.txt 自动安装 python如果你之前使用的是 pyenv 来管理 python 的版本，当使用 pipenv install 的时候 pipenv 会自动检测 python 是否存在，并询问你是否要安装该版本的 python 12345678910111213141516171819202122232425262728$ cat Pipfile[[source]]url = \"https://pypi.python.org/simple\"verify_ssl = true[dev-packages][packages]requests = \"*\"[requires]python_version = \"3.6\"$ pipenv installWarning: Python 3.6 was not found on your system…Would you like us to install latest CPython 3.6 with pyenv? [Y/n]: yInstalling CPython 3.6.2 with pyenv (this may take a few minutes)…...Making Python installation global…Creating a virtualenv for this project…Using /Users/apple/.pyenv/shims/python3 to create virtualenv…...No package provided, installing all dependencies....Installing dependencies from Pipfile.lock…🐍 ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ 5/5 — 00:00:03To activate this project's virtualenv, run the following: $ pipenv shell 修改默认 python 版本Pipenv 默认使用 python3 来初始化项目，你可以通过 使用 –three 或者 –two 标识来改变初始化环境的 python 版本。也可以指定 PIPENV_DEFAULT_PYTHON_VERSION 值来指定 python 版本。 自动加载 .env 文件如果在你的项目中包含 .env 文件，使用 $ pipenv shell 和 $ pipenv run 将会自动加载该文件。如果你的 .env 文件没有在当前目录下，或者不叫 .env ,你可以使用如果命令指定文件位置或名称 1PIPENV_DOTENV_LOCATION=/path/to/.env pipenv shell 阻止 pipenv 自动加载 .env 文件 1PIPENV_DONT_LOAD_ENV=1 pipenv shell 更多高级命令及使用详细内容可参考：advanced 结合 vs code 使用vs code 已经支持 pipenv 的使用，官方说明： A pipenv environment for the workplace folder. If one is found then no other interpreters are searched for or listed as pipenv expects to manage all aspects of the environment. 大意是：项目如果使用 pipenv 环境，一旦发现使用了 pipenv ，则只列出此项目的 interpreter ，不会在搜索其他的 python 解析器，因为 pipenv 可以管理环境的各个方面。 使用 vs code 作为开发工具，打开已经生成 Pipfile 文件的项目，在选择 python interperter (⇧⌘P) 时，可能会遇到以下错误提示： 12Workspace contains pipfile but attempt to run pipenv --venv failed with Traceback (most recent call last):File /usr/local/Cellar/pipenv/11.10.3/libexec/bin/pipenv, line 11, in &lt;module&gt; load_entry_point(pipenv==11.10.3, console_scripts, pipenv)() File /usr/local/Cellar/pipenv/11.10.3/libexec/lib/python3.6/site-packages/pipenv/vendor/click/core.py, line 722, in __call__ return self.main(*args, **kwargs) File /usr/local/Cellar/pipenv/11.10.3/libexec/lib/python3.6/site-packages/pipenv/vendor/click/core.py, line 676, in main _verify_python3_env() File /usr/local/Cellar/pipenv/11.10.3/libexec/lib/python3.6/site-packages/pipenv/vendor/click/_unicodefun.py, line 118, in _verify_python3_env for mitigation steps. + extra) RuntimeError: Click will abort further execution because Python 3 was configured to use ASCII as encoding for the environment. Consult http://click.pocoo.org/python3/for mitigation steps. This system lists a couple of UTF-8 supporting locales that you can pick from. The following suitable locales where discovered: af_ZA.UTF-8, am_ET.UTF-8, be_BY.UTF-8, bg_BG.UTF-8, ca_ES.UTF-8, cs_CZ.UTF-8, da_DK.UTF-8, de_AT.UTF-8, de_CH.UTF-8, de_DE.UTF-8, el_GR.UTF-8, en_AU.UTF-8, en_CA.UTF-8, en_GB.UTF-8, en_IE.UTF-8, en_NZ.UTF-8, en_US.UTF-8, es_ES.UTF-8, et_EE.UTF-8, eu_ES.UTF-8, fi_FI.UTF-8, fr_BE.UTF-8, fr_CA.UTF-8, fr_CH.UTF-8, fr_FR.UTF-8, he_IL.UTF-8, hr_HR.UTF-8, hu_HU.UTF-8, hy_AM.UTF-8, is_IS.UTF-8, it_CH.UTF-8, it_IT.UTF-8, ja_JP.UTF-8, kk_KZ.UTF-8, ko_KR.UTF-8, lt_LT.UTF-8, nl_BE.UTF-8, nl_NL.UTF-8, no_NO.UTF-8, pl_PL.UTF-8, pt_BR.UTF-8, pt_PT.UTF-8, ro_RO.UTF-8, ru_RU.UTF-8, sk_SK.UTF-8, sl_SI.UTF-8, sr_YU.UTF-8, sv_SE.UTF-8, tr_TR.UTF-8, uk_UA.UTF-8, zh_CN.UTF-8, zh_HK.UTF-8, zh_TW.UTF-8. Make sure pipenv is on the PATH. 解决方法：如果是简体中文环境，则在 ~/.bash_profile (~/.zshrc) 中设置如下变量： 12export LC_ALL=zh_CN.UTF-8export LANG=zh_CN.UTF-8 英文环境，设置： 12export LC_ALL=en_US.UTF-8export LANG=en_US.UTF-8 然后执行 1source .bash_profile(.zshrc) （不推荐）如果任然报错，则可以在项目目录下新建 .env 文件，并拷贝上文中的 shell 脚本。 总结 pipenv 主要是用来解决 python 版本和包依赖的管理 熟悉了 pipenv 安装和虚拟环境的搭建 通过示例来学习 pipenv 的基本命令使用 通过学习高级命令来使项目具有工程上的可用 了解使用过程中可能遇到的问题和解决方法 参考资料 pipenv docpipenv githubpipenv 试用过程分享","categories":[{"name":"Technology","slug":"Technology","permalink":"https://blog.51itzone.cn/categories/Technology/"},{"name":"python","slug":"Technology/python","permalink":"https://blog.51itzone.cn/categories/Technology/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.51itzone.cn/tags/python/"},{"name":"pipenv","slug":"pipenv","permalink":"https://blog.51itzone.cn/tags/pipenv/"}]},{"title":"详解redis及Ubuntu的安装和运行","slug":"redis-info-install-start-stop","date":"2017-10-21T06:10:25.000Z","updated":"2018-08-20T02:11:16.649Z","comments":true,"path":"2017/10/21/redis-info-install-start-stop/","link":"","permalink":"https://blog.51itzone.cn/2017/10/21/redis-info-install-start-stop/","excerpt":"写作目的 了解redis的功能和特点 记录安装方法和步骤，方便复查 环境：ubuntu 16.04 LTS redis-4.0.2 每个知识点背后都有其原因，深究才会掌握知识的本真","text":"写作目的 了解redis的功能和特点 记录安装方法和步骤，方便复查 环境：ubuntu 16.04 LTS redis-4.0.2 每个知识点背后都有其原因，深究才会掌握知识的本真 简介Redis由Salvatore Sanfilippo开发于2009年，到今年9月21号已经发布了197个release版本，目前最新稳定版是4.0.2。Redis是一个开源的使用ANSIC语言编写、支持网络、可基于内存亦可持久化的日志型、灵活的、开源的、key-value存储系统。它允许用户存储大量的数据，而且没有关系数据库的限制。Redis和Memcached类似，但是解决了断电后数据完全丢失的情况(由于redis是异步复制，因此不保证数据完全不丢失，只是解决了不丢失的可能性），而且它支持更多元化的value类型，而且性能相对高效。同时它也支持多种编程语言调用：ActionScript, C, C++, C#, Chicken Scheme, Clojure, Common Lisp, D, Dart, Erlang, Go, Haskell, Haxe, Io, Java, JavaScript (Node.js), Julia, Lua, Objective-C, OCaml, Perl, PHP, Pure Data, Python, R[16], Racket, Ruby, Rust, Scala, Smalltalk and Tcl，并且通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分片。 Redis还支持主从异步复制，非常快的非阻塞初次同步、网络断开时自动重连局部重同步。其他特性包括： 事务 订阅/发布 Lua脚本 带TTL的键 LRU回收健 自动故障转移(failover) 1、数据模型作为Key-value型数据库，Redis也提供了键（Key）和键值（Value）的映射关系。但是，除了常规的数值或字符串，Redis的键值还可以是以下形式：==Lists, Sets, Sorted Sets, Hashes, HyperLogLogs,Bitmaps,Geospatial data(地理空间数据 since Redis 3.2)==。键值的数据类型决定了该键值支持的操作。Redis支持诸如列表、集合或有序集合的交集、并集、差集等高级原子操作；同时，如果键值的类型是普通数字，Redis则提供自增等原子操作。 2、持久化通常，Redis将数据全部存储于内存中，或被配置为使用虚拟内存(since Redis 2.3)，此功能已经被弃用，来保存到磁盘上。现在Redis可以通过以下两种方式实现数据持久化: 使用快照的方式，异步将内存中的数据不断写入磁盘； 使用AOF(append-only file)(since Redis 1.1)的方式，类似MySQL的日志方式，以增量的方式记录每次更新的日志。 前者性能较高，但是可能会引起一定程度的数据丢失；后者相反。默认情况下Redis每2秒会写入数据到文件系统，当然如果需要这个时间是可配置的。如果系统宕机，那么只会有几秒的数据会丢失。如果对此感兴趣，可以阅读作者的博文 Redis persistence demystified或者此文Redis官方文档(13) ——持久化 3、复制Redis支持将数据同步到多台从库上，这种特性对提高读取性能非常有益。Replication是Redis最重要的功能，但也是坑最多的功能，想掌握好，需要了解这些内容。 Redis 采用异步复制(since Redis 2.8)。 一个主服务器可以拥有多个从服务器。 从服务器可以接受其他从服务器的连接会形成==图状结构==。 Redis 的复制在主服务器上是非阻塞的。 Redis 的复制在从服务器上也是非阻塞的。 复制可以用来支持可伸缩性，用多个从服务器处理只读查询(例如，繁重的 SORT 操作可以分配到从服务器上)，也可以仅仅作为数据冗余。 4 高可用Redis Sentinel 是 Redis 的官方高可用解决方案，是设计用来帮助管理 Redis 实例的系统。用于完成下面 4 个任务： 监控(Monitoring)。Sentinel 不断检查你的主从实例是否运转正常。 通知(Notification)。Sentinel 可以通过 API 来通知系统管理员，或者其他计算机程序，被监控的 Redis 实例出了问题。 自动故障转移(Automatic failover)。如果一台主服务器运行不正常，Sentinel会开始一个故障转移过程，将从服务器提升为主服务器，配置其他的从服务器使用新的主服务器，使用 Redis 服务器的应用程序在连接时会收到新的服务器地址通知。 配置提供者(Configuration provider)。Sentinel 充当客户端服务发现的权威来源：客户端连接到 Sentinel 来询问某个服务的当前 Redis主服务器的地址。当故障转移发生时，Sentinel 会报告新地址。 5 集群支持分布式系统，成为Redis能持续不断发展的动力，也是能被广泛使用的亮点。我们看看redis集群都能做什么 Redis 集群提供一种运行 Redis 的方式，数据被自动的分片到多个 Redis 节点。 集群不支持处理多个键的命令，因为这需要在 Redis 节点间移动数据，使得 Redis 集群不能提供像 Redis 单点那样的性能，在高负载下会表现得不可预知。 Redis 集群也提供在网络分割（partitions）期间的一定程度的可用性，这就是在现实中当一些节点失败或者不能通信时能继续进行运转的能力。 当然上文只是对 Redis 功能的一个概览，如果想深入学习，每个特性都可以写一系列文章，本文就不再详细展开叙述。 安装及运行 redis1、检测是否有安装redis使用linux命令 whereis 查找是否安装 redis-cli 和 redis-server 12345ubuntu@ubuntu-linux:~$ whereis redis-cliredis-cli:ubuntu@ubuntu-linux:~$ whereis redis-serverredis-server: 2、安装 Redis通过 apt-get 命令安装 命令： 12sudo apt-get updatesudo apt-get install redis-server 通过下载官方安装包进行安装并解压 本文不是用 root 用户安装 命令： 12wget http://download.redis.io/releases/redis-4.0.2.tar.gztar -zxvf redis-4.0.2.tar.gz 移到解压后的 Redis 到/usr/local/redis-4.0.2 1sudo mv redis-4.0.2 /usr/local/ 编译以及安装 123cd /usr/local/redis-4.0.2makesuod make install 3、启动 Redis1sudo /usr/local/bin/redis-server ==注意：非 root 启动,如果用命令直接关闭redis，redis无法结束进程== 123411462:M 21 Nov 17:15:54.777 # User requested shutdown...11462:M 21 Nov 17:15:54.777 * Saving the final RDB snapshot before exiting.11462:M 21 Nov 17:15:54.777 # Failed opening the RDB file dump.rdb (in server root dir /usr/local/bin) for saving: Permission denied11462:M 21 Nov 17:15:54.777 # Error trying to save the DB, can't exit. 指定配置文件启动 12sudo /usr/local/bin/redis-server /usr/local/redis-4.0.2/redis.conf &amp; 检测后台进程是否存在 1ps -ef |grep redis 检测 6379 端口是否在监听 1netstat -lntp | grep 6379 使用 redis-cli 进行连接 12345678ubuntu@ubuntu-linux:/usr/local/bin$ redis-cli127.0.0.1:6379&gt; keys *(empty list or set)127.0.0.1:6379&gt; set redis redis-4.0.2OK127.0.0.1:6379&gt; get redis\"redis-4.0.2\"127.0.0.1:6379&gt; 4、停止 Redis 使用 redis-cli 停止 1redis-cli shutdown 或在 redis-cli 命令行中停止 12127.0.0.1:6379&gt; shutdownnot connected&gt; 直接 kill 掉进程（ Redis 可以妥善处理 SIGTERM 信号） 1kill -9 PID 总结Redis 是开发人员必备的利器，掌握好 Redis 的功能特性并使用到实际场景才能真正体会到 Redis 的带来的便利。目前 Redis 主要应用场景如下： 构建高可用的缓存系统 积分排行榜（ sorted set ） 计数器 分布式锁 消息中间件（ message queue / pub/sub) web服务器的session管理 参考资料 Redis Redis wikipedia the-little-redis-book Redis3.0官方文档翻译和源码解析","categories":[{"name":"Technology","slug":"Technology","permalink":"https://blog.51itzone.cn/categories/Technology/"},{"name":"Redis","slug":"Technology/Redis","permalink":"https://blog.51itzone.cn/categories/Technology/Redis/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.51itzone.cn/tags/Ubuntu/"},{"name":"redis","slug":"redis","permalink":"https://blog.51itzone.cn/tags/redis/"}]},{"title":"LinkedList 实现分析及使用","slug":"linkedlist-analysis-and-use","date":"2016-02-26T10:46:00.000Z","updated":"2018-08-20T02:11:16.648Z","comments":true,"path":"2016/02/26/linkedlist-analysis-and-use/","link":"","permalink":"https://blog.51itzone.cn/2016/02/26/linkedlist-analysis-and-use/","excerpt":"jdk中的绝大部分代码都是经过千锤百炼的，代码质量非常之高，在了解其底层实现的过程中，也可以帮助我们提高编码规范，养成良好的习惯。知识在于总结和利用，基础知识的完善会让工作变更加轻松。本文通过分析 LinkedList 的底层实现来学习 LinkdedList 的使用。","text":"jdk中的绝大部分代码都是经过千锤百炼的，代码质量非常之高，在了解其底层实现的过程中，也可以帮助我们提高编码规范，养成良好的习惯。知识在于总结和利用，基础知识的完善会让工作变更加轻松。本文通过分析 LinkedList 的底层实现来学习 LinkdedList 的使用。 LinkedList 实现分析LinkedList 是实现 list 的线性存储结构的一个重要的实现类，LinkedList 是通过链表的形式存放数据，而ArrayList和Vector是通过数组存储的顺序结构。当然， LinkedList 也是非线程安全的，我们会在后文说明如何在多线程环境中使用它。 LinkedList具体实现类图如下： 通过图中的我们可以清晰的看到 LinkedList 即实现了 list 接口又实现了 Deque 接口。那说明 LinkedList 具有所有 list 的功能同时，还具备队列的功能。通过阅读 JDK 的源码文档，我们发现 LinkedList 是基于双向队列的数据结构实现的 （Doubly-linked list）。 具体结构我们可以参考下图： 双向链表的数据结构LinkedList 是通过链表结构来存储数据,而且实现的是双向链表。双向链表是数据结构的一种形式，他的每个节点维护两个指针， prev 指向上一个节点，next 指向下一个节点。这种结构有什么特点呢？他可以实现双向遍历，这使得在链表中的数据读取变得非常灵活自由。同时，LinkedList 中维护了两个指针，一个指向头部，一个指向尾部。维护这两个指针后，可以使得元素从头部插入，也可以使元素从尾部插入。基于方式，用户很容易就能实现 FIFO(队列)， LIFO(栈)等效果。那么下面我们来看一下源码中的具体实现。 Node定义1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; LinkedList列表的新增123456789101112131415161718public boolean add(E e) &#123; linkLast(e); return true;&#125;/*** Links e as last element.*/void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; 可见每次插入都是移动引用，和 ArrayList 的拷贝数组来说效率要高上不少。 LinkedList列表的查询1234567891011121314151617181920public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125;Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; LinkedList使用二分查找来看 index 离 size 中间距离来判断是从头结点正序查还是从尾节点倒序查。这样的效率是非常低的，特别是当 index 距离 size 的中间位置越远时。 LinkedList 迭代实现LinkedList 的迭代器实现有两个，一个是实现了Iterator接口的DescendingIterator，另一个则是实现了 ListIterator 接口的 ListItr 。 ListItr 实现ListItr遍历需要指定一个起始值 1234public ListIterator&lt;E&gt; listIterator(int index) &#123; checkPositionIndex(index); return new ListItr(index);&#125; ListItr 会创建一个以 index 为起始值的迭代器，然后用户便可以以这个位置为起点，实现向前或者向后遍历。 12345678910111213141516171819202122232425262728ListItr(int index) &#123; // 实例化的时候，将next指针指向指定位置的元素 next = (index == size) ? null : node(index); nextIndex = index;&#125;// 向后遍历public E next() &#123; checkForComodification(); if (!hasNext()) throw new NoSuchElementException(); lastReturned = next; next = next.next; nextIndex++; return lastReturned.item;&#125;// 向前遍历public E previous() &#123; checkForComodification(); if (!hasPrevious()) throw new NoSuchElementException(); lastReturned = next = (next == null) ? last : next.prev; nextIndex--; return lastReturned.item;&#125; DescendingIterator 实现DescendingIterator 迭代器实现的是对链表从尾部向头部遍历的功能，他复用了ListItr中的previous方法，将当前位置指向链表尾部，然后逐个向前遍历。 123456789101112private class DescendingIterator implements Iterator&lt;E&gt; &#123; private final ListItr itr = new ListItr(size()); public boolean hasNext() &#123; return itr.hasPrevious(); &#125; public E next() &#123; return itr.previous(); &#125; public void remove() &#123; itr.remove(); &#125;&#125; LinkedList 的队列实现从图1我们可以发现 LinkedList 实现了 Deque 接口，以下我们可以从实现队列的功能来看 LinkedList 的源码 LikedList 的 FIFO 队列的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 入队功能，入尾//在队列尾部增加一条记录，建议使用public boolean offer(E e) &#123; return add(e);&#125;public boolean offerLast(E e) &#123; addLast(e); return true;&#125;//在队列尾部增加一条记录public boolean add(E e) &#123; linkLast(e); return true;&#125;//方法包装，同样调用了linkLast的方法public void addLast(E e) &#123; linkLast(e);&#125;void linkLast(E e) &#123; final Node&lt;E&gt; l = last; //创建一个节点，将 prev 指针指向链表的尾节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; //将last指针指向新创建的这个节点 if (l == null) //如果当前链表为空，那么将头指针也指向这个节点 first = newNode; else //将链表的尾节点的next指针指向新建的节点，这样就完整的实现了在链表尾部添加一个元素的功能 l.next = newNode; size++; modCount++;&#125;//出队功能，从尾出队//在队列头部取出一个元素并删除， 队列操作建议使用这个方法public E poll() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);&#125;//同上，都调用了 unlinkFirst 方法public E pollFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);&#125;private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element;&#125; LinkedList 的 LIFO (栈)实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 在链表的头部添加一个元素public void push(E e) &#123; addFirst(e);&#125;// addFirst 调用的就是 linkFirst ，这段代码就是实现将元素添加的链表头部。private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; // 创建一个新元素，将元素的 next 指针指向当前的头结点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); // 将头指针指向这个节点。 first = newNode; if (f == null) // 如果当前节点为空，则把尾指针指向这个节点。 last = newNode; else // 将当前头结点的 prev 指针指向此结点。 f.prev = newNode; size++; modCount++;&#125;// 弹出顶部结点。public E pop() &#123; return removeFirst();&#125;// removeFirst 调用的就是 unlinkFirst，unlinkFirst 实现将链表顶部元素删除private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element;&#125;// 获取顶部结点，但是不删除public E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;&#125; 总结： 克服数组链表需要预先知道数据大小的缺点。 可以充分利用计算机内存空间，实现灵活的内存动态管理。 LinkedList 插入，删除都是移动引用效率很高。 查找需要进行遍历查询，效率较低。","categories":[{"name":"Technology","slug":"Technology","permalink":"https://blog.51itzone.cn/categories/Technology/"},{"name":"Java","slug":"Technology/Java","permalink":"https://blog.51itzone.cn/categories/Technology/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.51itzone.cn/tags/Java/"}]},{"title":"ArrayList & Vector 实现分析","slug":"ArrayList-Vector-analysis","date":"2016-02-20T10:46:00.000Z","updated":"2018-08-20T02:11:16.647Z","comments":true,"path":"2016/02/20/ArrayList-Vector-analysis/","link":"","permalink":"https://blog.51itzone.cn/2016/02/20/ArrayList-Vector-analysis/","excerpt":"通过阅读 ArrayList 与 Verctor 的源码我们发现，它们的代码实现近似度几乎在90%。所以我把它们两个合并起来进行说明，细心的读者可以自行去IDE中阅读，比对他们的实现结构。本文主要结合 JDK8 源码介绍了 ArrayList 和 Vector 的创建、增、删、改以及集合的迭代和 fail-fast 机制，并说明了在操作子集的一些注意事项及原因。 无特别说明，JDK 源码讲解都是基于 JDK8 进行的分析。","text":"通过阅读 ArrayList 与 Verctor 的源码我们发现，它们的代码实现近似度几乎在90%。所以我把它们两个合并起来进行说明，细心的读者可以自行去IDE中阅读，比对他们的实现结构。本文主要结合 JDK8 源码介绍了 ArrayList 和 Vector 的创建、增、删、改以及集合的迭代和 fail-fast 机制，并说明了在操作子集的一些注意事项及原因。 无特别说明，JDK 源码讲解都是基于 JDK8 进行的分析。 ArrayList 和 Vector 的异同在讲它们的异同点之前，我们先看看 ArrayList 和 Vector 的继承结构图 相同点 都是有序的，插入元素可重复，支持插入 null ，支持随机访问。 从上图可以发现 ArrayList 和 Vector 继承了相同的父类和实现了相同的接口，所以提供的功能也基本相同。 集合中维护的都是 Object 类型的数组，通过泛型方式来指定数组的类型。 初始如果没有指定集合的长度大小，则集合默认数组长度都为10。 都实现了 Iterator 和 ListIterator 接口，所以具有相同的遍历方式。 ArrayList 和 Vector 都具有动态扩容的特性。 不同点 Vector 的实现是线程安全的，因为操作集合的方法使用了关键字 Synchronized ，而使用线程同步的最大问题就是大并发下，操作集合程序性能会严重降低，而 ArrayList 的实现是线程不安全的，所以不考虑线程安全的情况，尽量使用 ArrayList。 当 ArrayList 和 Vector 的大小超过当前所能容纳元素的数组大小时，ArrayList 会扩大为当前数组的 50% 来容纳新元素，而 Vector中有一个capacityIncrement 变量，如果 capacityIncrement &gt; 0, 则每次扩容都在原来大小基础上增加 capacityIncrement 大小， 反之，Vector 就在原大小基础上再扩充一倍。 Vector中有一个方法 setSize(int newSize)，而ArrayList并没有。 setSize 允许用户主动设置容器大小，如果newSize小于当前 size ，那么elementData 数组中只会保留 newSize 个元素，多出来的会设为 null。如果newSize大于当前 size ，那么就扩容到 newSize 大小，数组中多出来的部分设为 null，以后添加元素的时候，之前多出来的部分就会以 null 的形式存在。 集合创建ArrayList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private static final int DEFAULT_CAPACITY = 10;/** * Shared empty array instance used for empty instances. */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;/*** 序列化时，忽略该值*/transient Object[] elementData;/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. * 与 EMPTY_ELEMENTDATA 区分开的目的是，添加第一个元素的时候可以确定数组的指定长度 */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;private int size;public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125;&#125;public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; ArrayList 提供了三种方式来进行初始化，当使用默认构造器初始化集合时，数据存储在静态变量 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 数组中，这个数组是由 static 和 final 修饰，使用静态变量的好处就是 JVM 加载类的同时，会把静态变量存储于 JVM 的方法区（各个线程共享的内存区域），与每次 new Object[initialCapacity] 相比，就减少了系统的开销，而使用 final 修饰指定该变量不能修改，是因为这是一个公共变量，修改后，会影响后续新初始化的 ArrayList。如果使用可以指定集合初始化大小构造器进行，如果指定大小为0 ，则把 EMPTY_ELEMENTDATA 赋值给初 elementData，如果指定的大小大于 0 ，则需要 new Object[initialCapacity] 并把新创建的数组赋值给 elementData 数组变量。DEFAULTCAPACITY_EMPTY_ELEMENTDATA 和 EMPTY_ELEMENTDATA 主要是为了区分不同构造器创建的 ArrayList 对象，这个后面会进行详细介绍。 ArrayList 提供接受实现 Collection 接口的实现类来进行初始化。 Vector123456789101112131415161718192021222324252627282930protected Object[] elementData;protected int elementCount;protected int capacityIncrement;public Vector(int initialCapacity, int capacityIncrement) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \" + initialCapacity); this.elementData = new Object[initialCapacity]; this.capacityIncrement = capacityIncrement;&#125;public Vector(int initialCapacity) &#123; this(initialCapacity, 0);&#125;public Vector() &#123; this(10);&#125;public Vector(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); elementCount = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, elementCount, Object[].class);&#125; Vector 与 ArrayList 不同的是提供了一个可以指定 capacityIncrement （增加因子）的构造器，增长因子的作用主要是对数组进行扩容时，指定数组在原来数组长度的基础上在扩容多大。 集合增加、修改元素ArrayList 集合新增元素主要是调用 add(E e) 和 add(int index, E element) 方法，添加元素之前，都需要对数组扩容进行检查，add(E e) 在数组末尾添加元素，add(int index, E element) 是在数组指定位置添加元素，所以该位置后的原数组元素都要向后移动一位。修改元素调用 set(int index, E e)，替换掉元数组，size 不变，下面我们通过具体源码进行学习。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123public boolean add(E e) &#123; // 检查扩容 ensureCapacityInternal(size + 1); // Increments modCount!! //每次都会把最新添加的元素放到数组末尾 elementData[size++] = e; return true;&#125;public void add(int index, E element) &#123; //检查数组是否越界 rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! //移动指定位置后的元素 System.arraycopy(elementData, index, elementData, index + 1, size - index); //插入元素 elementData[index] = element; size++;&#125;// 添加集合元素public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount // 数组移动并拷贝到 elementData 数组中 System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0;&#125;//在指定位置添加集合元素public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) //对自身进行移动并 copy 元素 System.arraycopy(elementData, index, elementData, index + numNew, numMoved); // copy 集合中的元素到 elementData 中 System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; // DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的作用 //使用默认构造器创建的对象，第一次新增元素时，指定数组默认长度为10 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125;private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //oldCapacity &gt;&gt; 1和oldCapacity / 2是等效的，newCapacity为原来的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) //数组不是无限大，需注意 newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: //进行数组拷贝，Arrays.copyOf的底层是一个native方法 elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125;public E set(int index, E element) &#123; rangeCheck(index); //查找元素 O(1) E oldValue = elementData(index); //替换掉原数据 elementData[index] = element; return oldValue;&#125;private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;/** * A version of rangeCheck used by add and addAll. */private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;@SuppressWarnings(\"unchecked\")E elementData(int index) &#123; return (E) elementData[index];&#125; 动态扩容ArrayList 和 Vector 的新增、修改元素的逻辑基本一致，不同的地方就是会在每个方法上使用 synchronized 关键字进行同步，这里重点说明下他们动态扩容的不同之处. Vector 的动态扩容机制 1234567891011121314151617181920212223242526272829303132333435363738public synchronized boolean add(E e) &#123; modCount++; //数组扩容 ensureCapacityHelper(elementCount + 1); //末尾插入元素 elementData[elementCount++] = e; return true;&#125;private void ensureCapacityHelper(int minCapacity) &#123; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // capacityIncrement &gt; 0 则扩容 capacityIncrement 大小，否则扩容原来的一倍 int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 结合 ArrayList 的扩容代码，可以明显看出与 Vector 的不同之处，所以使用类之前阅读代码是很好的编程习惯。 删除集合里的元素我们这里使用 ArrayList 来说明集合删除元素的逻辑，删除也分为对单个元素的删除和集合删除。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) //直接进行数组拷贝操作，把index后的所有元素向前移动一位。 System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125;public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;//之所以叫做快速删除，是因为他被设置为一个私有方法，只能在内部调用，删除元素的时候，省去了数组越界的判断。//也不返回被删除的元素，直接进行数组拷贝操作。private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125;//删除集合中指定的元素，指定中的集合元素不能为 nullpublic boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false);&#125;// 删除不在集合中的元素public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true);&#125;//批量循环删除private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) // c.contains 默认的是 Collection 接口的方法，在 AbstractCollection 中采用 Iterator 机制来判断是否包含元素，ArrayList 自己实现了此方法 // complement 删除方法调用传入的是 false // 第一，作者巧妙的提取了逻辑上的最大公约数，仅通过一行逻辑判断就实现了两个互斥的效果。 // 第二，作者的所用操作都集中于 elementData 一个数组上，避免了资源的浪费。 if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, even if c.contains() throws. // 理论上r==size 只有当出现异常情况的时候，才会出现r!=size，一旦出现了异常，那么务必要将之前被修改过的数组再还原回来。 if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; // 删除 w 位置后的元素 if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified;&#125; 集合元素的迭代（顺序迭代）ArrayList 迭代器是通过实现 Iterator 接口 和 ListIterator 接口实现集合的顺序迭代，Iterator 接口主要是向后遍历集合元素，遍历的同时可以对集合中的元素进行删除。ListIterator 是 List 接口提供的方法返回类型，集合类自行实现 ListIterator 接口来实现双向迭代功能， 同时 ListIterator 接口在 Iterator 接口的功能上提供了向前遍历，指定位置前后遍历，修改集合元素，添加集合元素的功能。我们通过源码具体分析 ArrayList 迭代器的实现。 Iterator 接口Iterator 接口规范了 Java 集合迭代的方式，通过使用迭代器，方便的迭代集合中的元素。同时也是设计模式里的迭代器模式在 JDK 里的具体实现。Java集合中实现 Collection 接口的都实现了 Iterable 接口。 Iterable 接口12345678910111213141516171819public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator(); // add JDK1.8 default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125; &#125; // add JDK1.8 // JDK 1.8 提供的分割迭代 default Spliterator&lt;T&gt; spliterator() &#123; return Spliterators.spliteratorUnknownSize(iterator(), 0); &#125;&#125; 123456789101112131415161718192021222324 public interface Iterator&lt;E&gt; &#123; //判断是否存在下一个元素对象 boolean hasNext(); //获取下一个元素 E next(); // JDK 1.8 支持接口里的方法可以有实现 //删除一个元素 default void remove() &#123; throw new UnsupportedOperationException(\"remove\"); &#125; // JDK 1.8 新增 default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (hasNext()) action.accept(next()); &#125; &#125;` ArrayList 的 iterator 代码实现分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155//Iterable 接口的方法实现public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125;//An optimized version of AbstractList.Itr//大家可以看下 AbstractList 的 Itr 实现private class Itr implements Iterator&lt;E&gt; &#123; // 游标 int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such //集合修改标志 //关于快速失败机制的实现，稍后会有讲解 int expectedModCount = modCount; Itr() &#123;&#125; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; // 检查集合是否被修改 checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; // 调用此方法前，必须调用 next() 方法, 如果不调 next() 方法, 那么 lastRet == -1,程序会报错抛异常 public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125;// List 接口的方法实现public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0);&#125;// 在指定位置处遍历public ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(\"Index: \"+index); return new ListItr(index);&#125;// 继承 Itr 类，同时拥有父类的所有特性private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; //指定位置进行遍历 ListItr(int index) &#123; super(); cursor = index; &#125; //向前遍历集合 public boolean hasPrevious() &#123; return cursor != 0; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; @SuppressWarnings(\"unchecked\") public E previous() &#123; checkForComodification(); // 向前遍历，游标 - 1 int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[lastRet = i]; &#125; // 修改集合元素 public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; // 新增集合元素 public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; ArrayList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125;&#125; 为什么要有迭代器我们已经清楚了 ArrayList 集合的具体迭代实现，但是有没有想过 Java 为什么要实现迭代器的方式来遍历集合呢，其中的奥秘和设计理念是什么，我们可以概况为： Iterator 接口提供了遍历集合类的规范。它把访问逻辑从不同类型的集合类中抽象出来，从而避免向客户端暴露集合的内部结构（数组、链表等结构）。例如，如果没有使用 Iterator，遍历一个数组的方法是使用索引： 123for (int i=0; i&lt;array.size(); i++) &#123; // TODO: get(i) ...&#125; 而访问一个链表（LinkedList）又必须使用 while 循环： 123while ((e=e.next())!=null) &#123; // TODO: e.data() ...&#125; 以上两种方法客户端都必须事先知道集合的内部结构，访问代码和集合本身是紧耦合，无法将访问逻辑从集合类和客户端代码中分离出来，每一种集合对应一种遍历方法，客户端代码无法复用。更恐怖的是，如果以后需要把 ArrayList 更换为 LinkedList ，则原来的客户端代码必须全部重写。 为解决以上问题，Iterator模式总是用同一种逻辑来遍历集合： 123for (Iterator it = c.iterater(); it.hasNext(); ) &#123; //...&#125; 奥秘在于客户端自身不维护遍历集合的”指针”，所有的内部状态（如当前元素位置，是否有下一个元素）都由 Iterator 来维护，而这个 Iterator 由集合类通过工厂方法生成，因此，它知道如何遍历整个集合。客户端从不直接和集合类打交道，它总是控制 Iterator ，向它发送”向前”，”向后”，”取当前元素”的命令，就可以间接遍历整个集合。 fail-fast 机制通过阅读 ArrayList 迭代器源码，我们可以发现集合在迭代过程中，新增、修改或者删除集合元素时，程序有可能会抛出ConcurrentModificationException 异常，这个异常的设置，就是集合迭代 fail-fast 机制。大家可以在文章中搜索 ConcurrentModificationException 出现的地方，结合阅读源码来了解 fail-fast 机制实现逻辑。fail-fast 机制具体可以概况为： fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。 fail-fast 目的 迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出 ConcurrentModificationException。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。 fail-fast 原因ArrayList 集合维护了一个全局变量 modCount ， 初始值为 0， 它是集合 AbstractList 抽象类里的。当我们调用 ArrayList 的 add 、 remove 、 clear 方法， modCount 变量值会增加，可以发现 modCount 值是用来记录集合发生修改的次数。阅读 ArrayList 迭代器实现代码，我们发现程序中有 int expectedModCount = modCount 的逻辑，当我们要迭代集合时，创建的迭代器的 expectedModCount 与 modCount 值相同，而当 ArrayList 发生修改时，modCount 值发生变化，而迭代器并没有同步到modCount 值的变化，当程序调用迭代器 next 方法，会触发程序设置的 checkForComodification 方法，而此时 expectedModCount != modCount ,则抛出 ConcurrentModificationException 异常。当然，迭代的程序检查到数组越界异常，或者当 cursor 的值大于 ArrayList 的 elementData.length 的值，也会抛出 ConcurrentModificationException 异常。 fail-fast 机制具体案例单线程的情况下，直接调用 ArrayList 的 remove 方法 12345678910111213141516171819@Testpublic void singleThreadArrayList()&#123; List&lt;Integer&gt; integerList = new ArrayList&lt;Integer&gt;(); integerList.add(1); Iterator&lt;Integer&gt; iterator = integerList.iterator(); while (iterator.hasNext())&#123; Integer integer = iterator.next(); if(integer == 1)&#123; // 调用 ArrayList 的 remove 方法后，expectedModCount != modCount，抛异常 // 调用 Iterator 的 remove 方法，则程序执行正常 integerList.remove(integer); &#125; &#125;&#125; 程序运行后抛出异常： 多线程环境中，调用 Iterator 的 remove 方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;();@Testpublic void multiThreadArrayList()&#123; for(int i = 0 ; i &lt; 10;i++)&#123; integerList.add(i); &#125; Thread oneThread = new Thread(() -&gt; &#123; Iterator&lt;Integer&gt; iterator = integerList.iterator(); while (iterator.hasNext())&#123; int value = iterator.next(); System.out.println(\"thread one iterator value:\" + value); try &#123; Thread.sleep(1L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); Thread twoThread = new Thread(() -&gt;&#123; Iterator&lt;Integer&gt; iterator = integerList.iterator(); while (iterator.hasNext())&#123; int value = iterator.next(); System.out.println(\"thread two iterator value:\" + value); if( value == 8)&#123; System.out.println(\"thread two remove value:\" + value); iterator.remove(); &#125; &#125; &#125;); oneThread.start(); twoThread.start(); try &#123; //等待线程 one 执行完成 oneThread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 程序运行后抛出异常： 多线程的情况下修改集合元素一定要谨慎，以免程序异常。 子集操作及注意事项有时我们可能只想取得 List 集合中的某段连续的集合元素，ArrayList 和 Vector 都提供了 subList 方法来截取集合的一部分来方便我们的使用。但是，这个功能带来方便的同时，也需要注意： subList 返回仅仅只是集合对象一个视图，操作 subList 后原集合对象也会被修改。 SubList 类是 ArrayList 类里的一个内部类，subList 也提供了操作集合的 新增 add ，修改 set, 删除 remove, 获取 get 等方法，还实现了子集合迭代的功能。我们通过源码看看其内部实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236// 从当前 List 中创建一个指定起始位置和结束位置的 subListpublic List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; // 边界检查 subListRangeCheck(fromIndex, toIndex, size); // this 指代当前对象，并传到 SubList 中 return new SubList(this, 0, fromIndex, toIndex);&#125;static void subListRangeCheck(int fromIndex, int toIndex, int size) &#123; if (fromIndex &lt; 0) throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex); if (toIndex &gt; size) throw new IndexOutOfBoundsException(\"toIndex = \" + toIndex); if (fromIndex &gt; toIndex) throw new IllegalArgumentException(\"fromIndex(\" + fromIndex + \") &gt; toIndex(\" + toIndex + \")\");&#125;private class SubList extends AbstractList&lt;E&gt; implements RandomAccess &#123; private final AbstractList&lt;E&gt; parent; private final int parentOffset; private final int offset; int size; SubList(AbstractList&lt;E&gt; parent, int offset, int fromIndex, int toIndex) &#123; this.parent = parent; this.parentOffset = fromIndex; this.offset = offset + fromIndex; this.size = toIndex - fromIndex; this.modCount = ArrayList.this.modCount; &#125; // 修改子集合中的元素 public E set(int index, E e) &#123; rangeCheck(index); checkForComodification(); // 获取到 this 对象的 ArrayList 中的元素 E oldValue = ArrayList.this.elementData(offset + index); // 同时 this 指代的 ArrayList 集合中的元素也被修改 ArrayList.this.elementData[offset + index] = e; return oldValue; &#125; // 获取子集合中指定位置的元素 public E get(int index) &#123; rangeCheck(index); // 检查是否修改，fail-fast 机制 checkForComodification(); return ArrayList.this.elementData(offset + index); &#125; // 子集合长度的大小 public int size() &#123; checkForComodification(); return this.size; &#125; // 在指定位置修改集合元素 public void add(int index, E e) &#123; rangeCheckForAdd(index); checkForComodification(); parent.add(parentOffset + index, e); this.modCount = parent.modCount; this.size++; &#125; //删除指定位置的元素 public E remove(int index) &#123; rangeCheck(index); checkForComodification(); E result = parent.remove(parentOffset + index); this.modCount = parent.modCount; this.size--; return result; &#125; // 按照范围删除元素 protected void removeRange(int fromIndex, int toIndex) &#123; checkForComodification(); parent.removeRange(parentOffset + fromIndex, parentOffset + toIndex); this.modCount = parent.modCount; this.size -= toIndex - fromIndex; &#125; // 增加集合元素 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(this.size, c); &#125; // 指定位置出增加集合元素 public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); int cSize = c.size(); if (cSize==0) return false; checkForComodification(); parent.addAll(parentOffset + index, c); this.modCount = parent.modCount; this.size += cSize; return true; &#125; // 迭代实现 public Iterator&lt;E&gt; iterator() &#123; return listIterator(); &#125; public ListIterator&lt;E&gt; listIterator(final int index) &#123; checkForComodification(); rangeCheckForAdd(index); final int offset = this.offset; return new ListIterator&lt;E&gt;() &#123; int cursor = index; int lastRet = -1; int expectedModCount = ArrayList.this.modCount; public boolean hasNext() &#123; return cursor != SubList.this.size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= SubList.this.size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[offset + (lastRet = i)]; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; @SuppressWarnings(\"unchecked\") public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[offset + (lastRet = i)]; &#125; @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = SubList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[offset + (i++)]); &#125; // update once at end of iteration to reduce heap write traffic lastRet = cursor = i; checkForComodification(); &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; SubList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = ArrayList.this.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(offset + lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; SubList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = ArrayList.this.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (expectedModCount != ArrayList.this.modCount) throw new ConcurrentModificationException(); &#125; &#125;; &#125; public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, offset, fromIndex, toIndex); &#125;&#125; 总结 ArrayList 和 Vector 是一个可扩展，有序 ，可以迭代的集合类实现 创建集合的时候，如果预先知道集合的大小，可以创建具体大小的集合，这样可以避免集合不断扩展而造成的性能影响 fail-fast 机制是为了预防并发修改集合元素，而造成的迭代集合元素不一致的问题。自行编程不能依赖于这种机制，只能用于检测 bug subList 返回仅仅只是集合对象一个视图，操作 subList 后原集合对象也会被修改 参考文章 When to use LinkedList over ArrayList?Java提高篇（三四）—–fail-fast机制Java中的fail-fast机制subList的缺陷Java: split a List into two sub-Lists?","categories":[{"name":"Technology","slug":"Technology","permalink":"https://blog.51itzone.cn/categories/Technology/"},{"name":"Java","slug":"Technology/Java","permalink":"https://blog.51itzone.cn/categories/Technology/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.51itzone.cn/tags/Java/"}]},{"title":"Ubuntu 下安装 Oracle JDK 的两种方法","slug":"ubuntu-install-java-two-method","date":"2016-02-13T12:50:25.000Z","updated":"2018-08-20T02:11:16.649Z","comments":true,"path":"2016/02/13/ubuntu-install-java-two-method/","link":"","permalink":"https://blog.51itzone.cn/2016/02/13/ubuntu-install-java-two-method/","excerpt":"总结 ubuntu 系统下安装 Oracle JDK 的方法，方便大家，以及备以后使用。","text":"总结 ubuntu 系统下安装 Oracle JDK 的方法，方便大家，以及备以后使用。 写在前面 添加ppa(源)，并下载安装 jdk 通过oracle官网下载压缩包安装 一、通过 ppa 安装 jdk1. 打开终端，执行以下命令：123sudo apt install software-properties-commonsudo add-apt-repository ppa:webupd8team/javasudo apt-get update 2. 执行安装 jdk 的命令：1sudo apt-get install oracle-java8-installer 安装过程，安装器会提示你同意 oracle 的服务条款,选择 ok 然后选择 yes 即可。当然，可以通过命令，默认执行同意选择 1echo oracle-java8-installer shared/accepted-oracle-license-v1-1selecttrue | sudo /usr/bin/debconf-set-selections 如果在过程中，网速较慢或者安装中断，我们可以去官网下载 jdk 的压缩包，放到/var/cache/oracle-jdk8-installer目录下，然后在执行安装命令，安装器则会默认使用我们下载的 jdk 版本进行安装。 3. 设置默认 jdk12345jdk7sudo update-java-alternatives -s java-7-oraclejdk8sudo update-java-alternatives -s java-8-oracle 4. 测试安装123java -versionjavac -version 二、通过官网下 jdk 压缩包安装1. 官网下载 jdk 压缩包shell下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html，选择相应版本的 jdk ，并下载压缩包。 2. 创建目录并解压缩 jdk创建目录： 1sudo mkdir /usr/lib/jvm 解压缩到创建的目录 1sudo tar -zxvf jdk-8u66-linux-x64.tar.gz -C /usr/lib/jvm 3. 增加 jdk 环境变量修改linux环境变量文件 1sudo vim /etc/profile 12345#set oracle jdk environmentexport JAVA_HOME=\"/usr/lib/jvm/jdk1.8.0_66\"export PATH=\"$PATH:$JAVA_HOME/bin\"export JRE_HOME=\"$JAVA_HOME/jre\"export CLASSPATH=\".:$JAVA_HOME/lib:$JRE_HOME/lib\" 4.使环境变量立即生效1source /etc/profile 5. 设置系统默认 jdk因为许多 linux 默认安装有 openjdk ，所以需要执行以下命令，设置默认 jdk 12345sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/jdk1.8.0_66/bin/java 300 sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/jdk1.8.0_66/bin/javac 300 sudo update-alternatives --install /usr/bin/jar jar /usr/lib/jvm/jdk1.8.0_66/bin/jar 300 sudo update-alternatives --install /usr/bin/javah javah /usr/lib/jvm/jdk1.8.0_66/bin/javah 300 sudo update-alternatives --install /usr/bin/javap javap /usr/lib/jvm/jdk1.8.0_66/bin/javap 300 这里的300只是标识一下，没什么意义，只是下一步要用到然后执行命令： 1sudo update-alternatives --config java 若是初次安装 jdk, 会有下面的提示There is only one alternative in link group java (providing /usr/bin/java)否者 , 会列出系统上的所有已安装的 java，然后自己选择，即选最后为300的那个 6. 测试 jdk 是否安装成功123java -versionjavac -version 另外删除通过 ppa 安装的 jdk 1sudo apt-get remove oracle-java8-installer 好，以上就安装 jdk 的两种方法，希望对大家有所帮助","categories":[{"name":"Technology","slug":"Technology","permalink":"https://blog.51itzone.cn/categories/Technology/"},{"name":"Java","slug":"Technology/Java","permalink":"https://blog.51itzone.cn/categories/Technology/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.51itzone.cn/tags/Java/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.51itzone.cn/tags/Ubuntu/"}]},{"title":"记录成为更好的自己","slug":"record-to-be-better","date":"2016-02-10T12:46:25.000Z","updated":"2018-08-20T02:11:16.649Z","comments":true,"path":"2016/02/10/record-to-be-better/","link":"","permalink":"https://blog.51itzone.cn/2016/02/10/record-to-be-better/","excerpt":"万事开头难，不管做什么最难的就是从零到一的过程。一直以来都想搭建自己的博客来记录自己的所思、所想、所感。写博客在于坚持，坚持下来记录自己的生活和想法，留下一些记忆。","text":"万事开头难，不管做什么最难的就是从零到一的过程。一直以来都想搭建自己的博客来记录自己的所思、所想、所感。写博客在于坚持，坚持下来记录自己的生活和想法，留下一些记忆。 写博客的好处 如何才能坚持写博客 一.写博客的好处1、学习写blog的技巧没有人天生会写blog，不断尝试，思考所写的内容，才会练就写出大家喜欢的博文。 2、编写读书笔记书读了很多，发现自己没有收获，用读书笔记来总结心得是个很不错的做法。 3、制定学习计划 学习过的知识需要总结，经常复习回顾，不然时间久了就会遗忘。把所学习的知识分享出来，与大家交流学习，同时自己也要定期回顾总结，温故知新么。 4、可以成就和了解自我文章写的多了，就会发现自己什么地方可以想清楚，什么地方需要改进和完善，写着写着就会对自己认识的更清晰，你最终会明白自己是一个什么样的人，和自己所感兴趣的是什么。 二、如何才能坚持写博客1、坚持，是一种优秀习惯坚持写博客需要做的以下四点：实践、反思、总结、坚持。不断的去在实践中总结反思、优化、坚持，才能真正学习到精髓。 2、时时刻刻的都要准备好开始写作善于利用身边的工具，比如Evernote、有道云笔记。当我们有写作的想法，但是时间不允许，我们可以在工具里先拟好要写的提纲和思考后总结出的内容。 3、收集写作内容，并转化为自己的文章推荐大家使用[稍后阅读]功能，比如知名的Pocket,支持多终端同步。然后我们可以把自己想写的内容收集起来，等有空了进行消化、总结和写作。 4、坚持写作，完成自我的营销现在是自媒体的天下，在这发达的互联网浪潮里，我们需要学会营销自己，展示自己才华，为自己创造价值也为他人创建价值，实现共赢。 三、总结写博客在于坚持，三分热度成就不了自己，也不能给别人带来帮助和价值。制定出明确的计划，把自己的所学转换成知识传递出去。记录，成为更好的自己。 刘未鹏说——写博客这件事情给我最大的体会就是，一件事情如果你能够坚持做8年，那么不管效率和频率多低，最终总能取得一些很可观的收益。而另一个体会就是，一件事情只要你坚持得足够久，“坚持”就会慢慢变成“习惯”。原本需要费力去驱动的事情便成了家常便饭，云淡风轻。","categories":[{"name":"LifeStyle","slug":"LifeStyle","permalink":"https://blog.51itzone.cn/categories/LifeStyle/"}],"tags":[{"name":"LifeStyle","slug":"LifeStyle","permalink":"https://blog.51itzone.cn/tags/LifeStyle/"}]}]}